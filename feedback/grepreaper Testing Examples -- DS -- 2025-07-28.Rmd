---
title: "grepreaper Tests -- 2025-07-28"
author: "David Shilane"
date: "2025-07-28"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


## Package Basics

```{r }
library(data.table)
library(grepreaper)
```


```{r }
citation(package = "grepreaper")
```


**Title**:  grepreaper:  Aggregated and Pre-Filtered File Reading with grep in R

**Authors**:  Atharv Raskar and David Shilane


## File Reading


```{r }
grep_read(files = "~/Downloads/diamonds.csv")
```

```{r }
grep_read(files = "~/Downloads/diamonds.csv", show_cmd = T)
```


Noted issues:

When reading from multiple files and showing the line numbers, we have an issue with losing the **carat** column's values:

```{r }
dat <- grep_read(files = c("~/Downloads/diamonds.csv", "~/Downloads/diamonds.csv"), show_line_numbers = T)
dat[1:2,]
```

This issue stems from how we are processing the outputs of grep into the final version of the data.

Let's walk through the steps of how to handle this issue.  First, we will obtain the grep command:

```{r }
cmd <- grep_read(files = c("~/Downloads/diamonds.csv", "~/Downloads/diamonds.csv"), show_line_numbers = T, show_cmd = T)
cmd
```

Then we will directly read data from the files based on the grep command:

```{r }
dat <- fread(cmd = cmd)
dat[1:2,]
```

Here we can see that the files, line numbers, and carat column have been condensed into a single column.  The function below will process these into separate columns

```{r }
split.columns <- function(x, column.names = NA, split = ":", fixed = T){
  the.pieces <- strsplit(x = x, split = split, fixed = fixed)
  
  new.columns <- rbindlist(l = lapply(X = the.pieces, FUN = function(y){return(as.data.table(t(y)))}))
  
  if(!is.na(column.names[1])){
    setnames(x = new.columns, old = names(new.columns), new = column.names)
  }
  return(new.columns)
}
```

Now we can apply this function to the 

```{r }
dat[, c("V1", "V2","V3") := split.columns(x = get(names(dat)[1]))]

dat[1:2,]
```

Then we would have to rename the columns (with the setnames function from data.table) and potentially reorder them (with setcolorder).

Note that this processing only needs to be done if we have files or line numbers included.  Furthermore, since split.columns() adds new columns to the data.table object, we could remove the first column after this is done.  As an example of these steps:

Removing the first column:

```{r }
dat[, eval(names(dat)[1]) := NULL]
dat[1:2,]
```

Changing the names of the new columns:

```{r }
setnames(x = dat, old = c("V1", "V2", "V3"), new = c("file", "line", "carat"))

dat[1:2,]
```

Changing the column ordering:

```{r }
setcolorder(x = dat, neworder = c("carat"))
dat[1:2,]
```

Then we would need to proceed with the clean-up process, such as changing the data types from character to numeric.

## Patterns


Only Matching:  It is not clear if this is working properly.  As an example, we can start from the full data.  There are rows with the value 3.94 in multiple variables:

```{r }
dat <- grep_read(files = "diamonds.csv", pattern = "3.94")

dat[, lapply(X = .SD, FUN = function(x){return(sum(x == "3.94"))})]
```


However, when we apply "only_matching", we only see one column:

```{r }
grep_read(files = "diamonds.csv", pattern = "3.94", only_matching = T)
```

Furthermore, some of the values listed here clearly do not match the pattern.  There are numbers like 3894.  So this means that the decimal point is used in a regular expression that will allow for any single character between 3 and 94.
