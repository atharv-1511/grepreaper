---
title: "grepreaper Package - Comprehensive Testing Suite"
author: "Package Quality Assurance"
date: "`r Sys.Date()`"
output: 
  html_document:
    toc: true
    toc_float: true
    theme: cosmo
    highlight: tango
    code_folding: show
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  warning = FALSE,
  message = FALSE,
  error = FALSE,
  fig.width = 10,
  fig.height = 6
)

# Set PATH for Windows users (Git grep utility)
if (Sys.info()["sysname"] == "Windows") {
  Sys.setenv(PATH = paste("C:/Program Files/Git/usr/bin", Sys.getenv("PATH"), sep=";"))
}

# Load required packages
library(data.table)
library(grepreaper)

# Test results tracking
test_results <- list()
add_test_result <- function(test_name, passed, details = "") {
  test_results[[test_name]] <<- list(
    passed = passed,
    details = details,
    timestamp = Sys.time()
  )
}
```

# üß™ **grepreaper Package - Comprehensive Testing Suite**

This document provides thorough testing of the grepreaper package to ensure it works reliably for users worldwide. The package handles file reading, pattern matching, and data processing with various file formats and edge cases.

## üìã **Test Setup and Data Preparation**

```{r data_prep}
# Verify test data files exist
cat("Checking test data files...\n")
test_files <- c("data/diamonds.csv", "data/sample_data.csv")

for (file in test_files) {
  if (file.exists(file)) {
    cat("‚úÖ", file, "available\n")
  } else {
    cat("‚ùå", file, "not found\n")
  }
}
```

## üîç **Core Functionality Tests**

### **Test 1: Basic File Reading**

```{r basic_reading}
cat("=== TEST 1: Basic File Reading ===\n")

# Test single file reading
tryCatch({
  result <- grep_read(files = "data/diamonds.csv", pattern = "")
  add_test_result("basic_single_file", TRUE, paste("Rows:", nrow(result), "Columns:", ncol(result)))
  cat("‚úÖ Single file reading: PASS\n")
  cat("   Shape:", nrow(result), "x", ncol(result), "\n")
  cat("   Columns:", paste(names(result), collapse = ", "), "\n")
}, error = function(e) {
  add_test_result("basic_single_file", FALSE, e$message)
  cat("‚ùå Single file reading: FAIL -", e$message, "\n")
})
```

### **Test 2: Pattern Matching**

```{r pattern_matching}
cat("\n=== TEST 2: Pattern Matching ===\n")

# Test regex pattern matching
tryCatch({
  result <- grep_read(files = "data/diamonds.csv", pattern = "Premium")
  add_test_result("regex_pattern_matching", TRUE, paste("Matches found:", nrow(result)))
  cat("‚úÖ Regex pattern matching: PASS\n")
  cat("   Matches found:", nrow(result), "\n")
}, error = function(e) {
  add_test_result("regex_pattern_matching", FALSE, e$message)
  cat("‚ùå Regex pattern matching: FAIL -", e$message, "\n")
})

# Test fixed string matching
tryCatch({
  result <- grep_read(files = "data/diamonds.csv", pattern = "Premium", fixed = TRUE)
  add_test_result("fixed_pattern_matching", TRUE, paste("Matches found:", nrow(result)))
  cat("‚úÖ Fixed pattern matching: PASS\n")
  cat("   Matches found:", nrow(result), "\n")
}, error = function(e) {
  add_test_result("fixed_pattern_matching", FALSE, e$message)
  cat("‚ùå Fixed pattern matching: FAIL -", e$message, "\n")
})
```

### **Test 3: Multiple File Processing**

```{r multiple_files}
cat("\n=== TEST 3: Multiple File Processing ===\n")

# Test multiple files without filename
tryCatch({
  result <- grep_read(
    files = c("data/diamonds.csv", "data/diamonds.csv"), 
    pattern = "",
    show_line_numbers = FALSE, 
    include_filename = FALSE
  )
  
  # Check for NA values in key columns
  na_check <- sapply(result, function(x) sum(is.na(x)))
  has_na_issues <- any(na_check > 0)
  
  add_test_result("multiple_files_no_filename", !has_na_issues, 
                  paste("Rows:", nrow(result), "NA issues:", has_na_issues))
  
  if (!has_na_issues) {
    cat("‚úÖ Multiple files without filename: PASS\n")
    cat("   Shape:", nrow(result), "x", ncol(result), "\n")
    cat("   No NA values detected\n")
  } else {
    cat("‚ùå Multiple files without filename: FAIL\n")
    cat("   NA values found in columns:", names(na_check[na_check > 0]), "\n")
  }
}, error = function(e) {
  add_test_result("multiple_files_no_filename", FALSE, e$message)
  cat("‚ùå Multiple files without filename: FAIL -", e$message, "\n")
})
```

### **Test 4: Line Number Handling**

```{r line_numbers}
cat("\n=== TEST 4: Line Number Handling ===\n")

# Test with line numbers
tryCatch({
  result <- grep_read(
    files = c("data/diamonds.csv", "data/diamonds.csv"), 
    pattern = "Premium",  # Use a pattern to trigger grep processing
    show_line_numbers = TRUE, 
    include_filename = FALSE
  )
  
  # Verify line numbers are sequential
  if ("line_number" %in% names(result)) {
    line_seq_check <- all(diff(result$line_number) == 1)
    add_test_result("line_numbers_sequential", line_seq_check, 
                    paste("Rows:", nrow(result), "Sequential:", line_seq_check))
    
    if (line_seq_check) {
      cat("‚úÖ Line numbers with multiple files: PASS\n")
      cat("   Shape:", nrow(result), "x", ncol(result), "\n")
      cat("   Line numbers are sequential\n")
    } else {
      cat("‚ùå Line numbers with multiple files: FAIL\n")
      cat("   Line numbers are not sequential\n")
    }
  } else {
    add_test_result("line_numbers_sequential", FALSE, "No line_number column")
    cat("‚ùå Line numbers with multiple files: FAIL - No line_number column\n")
  }
}, error = function(e) {
  add_test_result("line_numbers_sequential", FALSE, e$message)
  cat("‚ùå Line numbers with multiple files: FAIL -", e$message, "\n")
})
```

### **Test 5: Filename Inclusion**

```{r filename_inclusion}
cat("\n=== TEST 5: Filename Inclusion ===\n")

# Test with filename inclusion
tryCatch({
  result <- grep_read(
    files = c("data/diamonds.csv", "data/diamonds.csv"), 
    pattern = "Premium",  # Use a pattern to trigger grep processing
    show_line_numbers = FALSE, 
    include_filename = TRUE
  )
  
  if ("source_file" %in% names(result)) {
    file_count <- length(unique(result$source_file))
    add_test_result("filename_inclusion", TRUE, paste("Files processed:", file_count))
    
    cat("‚úÖ Filename inclusion: PASS\n")
    cat("   Shape:", nrow(result), "x", ncol(result), "\n")
    cat("   Files processed:", file_count, "\n")
    cat("   Source files:", paste(unique(result$source_file), collapse = ", "), "\n")
  } else {
    add_test_result("filename_inclusion", FALSE, "No source_file column")
    cat("‚ùå Filename inclusion: FAIL - No source_file column\n")
  }
}, error = function(e) {
  add_test_result("filename_inclusion", FALSE, e$message)
  cat("‚ùå Filename inclusion: FAIL -", e$message, "\n")
})
```

### **Test 6: Edge Cases and Special Characters**

```{r edge_cases}
cat("\n=== TEST 6: Edge Cases and Special Characters ===\n")

# Test file with special characters - use diamonds.csv with special patterns
tryCatch({
  # Test with a pattern that contains special characters
  result <- grep_read(files = "data/diamonds.csv", pattern = "Premium", fixed = TRUE)
  
  # Check if the data contains special characters and is preserved
  has_data <- nrow(result) > 0
  has_special_chars <- any(grepl("[^a-zA-Z0-9\\s]", result$cut, perl = TRUE))
  
  add_test_result("special_characters", has_data && has_special_chars, 
                  paste("Data preserved:", has_data, "Special chars found:", has_special_chars))
  
  if (has_data && has_special_chars) {
    cat("‚úÖ Special characters: PASS\n")
    cat("   Shape:", nrow(result), "x", ncol(result), "\n")
    cat("   Data preserved:", has_data, "\n")
    cat("   Special characters found:", has_special_chars, "\n")
  } else {
    cat("‚ùå Special characters: FAIL\n")
    cat("   Data preserved:", has_data, "\n")
    cat("   Special characters found:", has_special_chars, "\n")
  }
}, error = function(e) {
  add_test_result("special_characters", FALSE, e$message)
  cat("‚ùå Special characters: FAIL -", e$message, "\n")
})
```

### **Test 7: Data Type Preservation**

```{r data_types}
cat("\n=== TEST 7: Data Type Preservation ===\n")

# Test data type handling
tryCatch({
  result <- grep_read(files = "data/diamonds.csv", pattern = "")
  
  # Check expected data types for diamonds.csv
  expected_types <- c(
    carat = "numeric",
    cut = "character", 
    color = "character",
    clarity = "character",
    depth = "numeric",
    table = "numeric",
    price = "numeric",  # Note: integer is also acceptable for whole numbers
    x = "numeric",
    y = "numeric",
    z = "numeric"
  )
  
  type_check <- sapply(names(expected_types), function(col) {
    if (col %in% names(result)) {
      actual_type <- class(result[[col]])[1]
      expected_type <- expected_types[col]
      return(actual_type == expected_type)
    }
    return(FALSE)
  })
  
  all_types_correct <- all(type_check)
  add_test_result("data_type_preservation", all_types_correct, 
                  paste("Correct types:", sum(type_check), "/", length(type_check)))
  
  if (all_types_correct) {
    cat("‚úÖ Data type preservation: PASS\n")
    cat("   All data types preserved correctly\n")
  } else {
    cat("‚ùå Data type preservation: FAIL\n")
    cat("   Type details:\n")
    for (col in names(type_check)) {
      if (col %in% names(result)) {
        actual_type <- class(result[[col]])[1]
        expected_type <- expected_types[col]
        status <- if(actual_type == expected_type) "‚úÖ" else "‚ùå"
        cat("     ", status, col, ":", actual_type, "(expected:", expected_type, ")\n")
      }
    }
  }
}, error = function(e) {
  add_test_result("data_type_preservation", FALSE, e$message)
  cat("‚ùå Data type preservation: FAIL -", e$message, "\n")
})
```

### **Test 8: Performance and Large File Handling**

```{r performance}
cat("\n=== TEST 8: Performance and Large File Handling ===\n")

# Test performance with larger dataset
tryCatch({
  start_time <- Sys.time()
  
  # Create a larger test file
  large_data <- data.frame(
    id = 1:10000,
    value = rnorm(10000),
    category = sample(LETTERS, 10000, replace = TRUE),
    stringsAsFactors = FALSE
  )
  write.csv(large_data, "large_test.csv", row.names = FALSE)
  
  result <- grep_read(files = "large_test.csv", pattern = "")
  
  end_time <- Sys.time()
  processing_time <- as.numeric(end_time - start_time)
  
  # Performance criteria: should process 10K rows in reasonable time
  performance_ok <- processing_time < 30  # 30 seconds threshold
  
  add_test_result("large_file_performance", performance_ok, 
                  paste("Time:", round(processing_time, 2), "s for", nrow(result), "rows"))
  
  if (performance_ok) {
    cat("‚úÖ Large file performance: PASS\n")
    cat("   Processed", nrow(result), "rows in", round(processing_time, 2), "seconds\n")
  } else {
    cat("‚ö†Ô∏è  Large file performance: SLOW\n")
    cat("   Processed", nrow(result), "rows in", round(processing_time, 2), "seconds\n")
    cat("   Consider optimization for very large files\n")
  }
  
  # Clean up large test file
  if (file.exists("large_test.csv")) file.remove("large_test.csv")
  
}, error = function(e) {
  add_test_result("large_file_performance", FALSE, e$message)
  cat("‚ùå Large file performance: FAIL -", e$message, "\n")
})
```

### **Test 9: Error Handling and Validation**

```{r error_handling}
cat("\n=== TEST 9: Error Handling and Validation ===\n")

# Test invalid inputs
test_cases <- list(
  "empty_files" = list(files = character(0), pattern = ""),
  "invalid_pattern" = list(files = "data/diamonds.csv", pattern = NULL),  # NULL pattern should cause error
  "nonexistent_file" = list(files = "nonexistent.csv", pattern = ""),
  "conflicting_params" = list(files = "data/diamonds.csv", pattern = "", count_only = TRUE, only_matching = TRUE),
  "invalid_nrows" = list(files = "data/diamonds.csv", pattern = "", nrows = -1)
)

for (test_name in names(test_cases)) {
  tryCatch({
    do.call(grep_read, test_cases[[test_name]])
    # If we get here, the function didn't catch the error
    add_test_result(paste0("error_handling_", test_name), FALSE, "Error not caught")
    cat("‚ùå", test_name, ": FAIL - Error not caught\n")
  }, error = function(e) {
    add_test_result(paste0("error_handling_", test_name), TRUE, e$message)
    cat("‚úÖ", test_name, ": PASS - Error caught:", e$message, "\n")
  })
}
```

### **Test 10: Advanced Features**

```{r advanced_features}
cat("\n=== TEST 10: Advanced Features ===\n")

# Test count only
tryCatch({
  result <- grep_read(files = c("data/diamonds.csv", "data/diamonds.csv"), pattern = "", count_only = TRUE)
  
  if ("count" %in% names(result)) {
    add_test_result("count_only_feature", TRUE, paste("Counts:", paste(result$count, collapse = ", ")))
    cat("‚úÖ Count only feature: PASS\n")
    cat("   Counts:", paste(result$count, collapse = ", "), "\n")
  } else {
    add_test_result("count_only_feature", FALSE, "No count column")
    cat("‚ùå Count only feature: FAIL - No count column\n")
  }
}, error = function(e) {
  add_test_result("count_only_feature", FALSE, e$message)
  cat("‚ùå Count only feature: FAIL -", e$message, "\n")
})

# Test only matching
tryCatch({
  result <- grep_read(files = "data/diamonds.csv", pattern = "Premium", fixed = TRUE, only_matching = TRUE)
  
  if ("match" %in% names(result)) {
    add_test_result("only_matching_feature", TRUE, paste("Matches:", nrow(result)))
    cat("‚úÖ Only matching feature: PASS\n")
    cat("   Matches found:", nrow(result), "\n")
  } else {
    add_test_result("only_matching_feature", FALSE, "No match column")
    cat("‚ùå Only matching feature: FAIL - No match column\n")
  }
}, error = function(e) {
  add_test_result("only_matching_feature", FALSE, e$message)
  cat("‚ùå Only matching feature: FAIL -", e$message, "\n")
})
```

## üìä **Test Results Summary**

```{r results_summary}
cat("\n=== COMPREHENSIVE TEST RESULTS ===\n")

# Calculate overall results
total_tests <- length(test_results)
passed_tests <- sum(sapply(test_results, function(x) x$passed))
failed_tests <- total_tests - passed_tests
success_rate <- round(passed_tests / total_tests * 100, 1)

cat("Total Tests:", total_tests, "\n")
cat("Passed:", passed_tests, "\n")
cat("Failed:", failed_tests, "\n")
cat("Success Rate:", success_rate, "%\n")

# Show detailed results
cat("\nDetailed Results:\n")
for (test_name in names(test_results)) {
  result <- test_results[[test_name]]
  status <- if(result$passed) "‚úÖ PASS" else "‚ùå FAIL"
  cat(sprintf("%-30s %s - %s\n", test_name, status, result$details))
}

# Overall assessment
if (success_rate >= 95) {
  cat("\nüéâ EXCELLENT: Package is ready for worldwide use!\n")
} else if (success_rate >= 80) {
  cat("\n‚ö†Ô∏è  GOOD: Package works well but has some issues to address\n")
} else {
  cat("\nüö® CRITICAL: Package has significant issues that need immediate attention\n")
}
```

## üßπ **Cleanup**

```{r cleanup}
# Test suite completed
cat("Test suite completed successfully!\n")
```

## üìù **Testing Notes**

This comprehensive testing suite covers:

- **Core Functionality**: Basic file reading, pattern matching, multiple file processing
- **Edge Cases**: Special characters, empty values, NA handling
- **Performance**: Large file processing capabilities
- **Error Handling**: Input validation and graceful error recovery
- **Data Integrity**: Type preservation and data accuracy
- **Advanced Features**: Count only, only matching, line numbers, filenames

## üéØ **Quality Assurance for Worldwide Users**

The grepreaper package is designed to be robust and reliable for users worldwide. These tests ensure:

1. **Reliability**: Functions work consistently across different scenarios
2. **Robustness**: Handles edge cases and invalid inputs gracefully
3. **Performance**: Processes files efficiently even at scale
4. **Accuracy**: Preserves data integrity and types
5. **Usability**: Clear error messages and intuitive behavior

## üîß **If Tests Fail**

If any tests fail:

1. **Check the error messages** for specific issues
2. **Verify package installation** is up to date
3. **Check system requirements** (grep availability, data.table package)
4. **Review the test data** to ensure it was created correctly
5. **Consider platform-specific issues** (Windows vs Unix)

---

**Package**: grepreaper  
**Version**: `r packageVersion("grepreaper")`  
**Test Date**: `r Sys.Date()`  
**R Version**: `r R.version.string`
